{"mappings":";;;;;;;;;ACAA;;AASO,MAAM,4CAAoB,CAAC,SAAlC;IACE,OAAO;QACL,SAAS,UAAT;YACE,OAAO,OAAO,UAAU;QAC1B;QACA,uBAAuB,OAAO,WAA9B;YACE,MAAM,SAAS,CAAA,GAAA,gBAAS,AAAT;YACf,MAAM,WAAW,SAAS,IAAI,EAAE;YAChC,IAAI;YACJ,IAAI,UAAU;gBACZ,yBAAyB;gBACzB,IAAI,SAAS,aAAa,KAAK,UAAU;oBACvC,OAAO,GAAG,CAAC;wBAAC;qBAAqC,EAAE,CAAA,GAAA,eAAQ,AAAR,EAAS,OAAO;oBACnE,IAAI,SAAS,OAAO,CAAC,KAAK,CAAC,sBACzB,6EAA6E;oBAC7E,YAAY,MAAM,OAAO,WAAW,CAAC,CAAA,GAAA,eAAQ,AAAR,EAAS,SAAS,OAAO;yBAE9D,YAAY,MAAM,OAAO,WAAW,CAAC,SAAS,OAAO;gBAExD,OAAM,IAAI,SAAS,aAAa,KAAK,UAAU;oBAC9C,OAAO,GAAG,CAAC;wBAAC;qBAAqC,EAAE,CAAA,GAAA,eAAQ,AAAR,EAAS,OAAO;oBACnE,YAAY,MACV,OACA,cAAc,CAAC,SAAS,MAAM,EAAE,SAAS,KAAK,EAAE,SAAS,KAAK;gBACjE,CAAA;YACF,CAAA;YACD,OAAO;QACT;QACA,2BAA2B,OAAO,SAAS,WAA3C;YACE,MAAM,OAAE,IAAG,EAAE,GAAG,UAAU,GAAG,SAAS,IAAI;YAC1C,MAAM,cAAc,MAAM,OAAO,eAAe,CAAC;gBAC/C,GAAG,QAAQ;gBACX,GAAI,OAAO;oBACT,UAAU;gBACX,CAAA;YACF;YACD,OAAO,YAAY,IAAqB;QAC1C;IACD;AACH;;ADhDA","sources":["packages/ethers-wallet-adapter/src/index.ts","packages/ethers-wallet-adapter/src/adapter.ts"],"sourcesContent":["export * from './adapter'\n","import {\n  LogLevel,\n  ReservoirWallet,\n  getClient,\n} from '@reservoir0x/reservoir-sdk'\nimport { Signer } from 'ethers/lib/ethers'\nimport { arrayify } from 'ethers/lib/utils'\nimport { TypedDataSigner } from '@ethersproject/abstract-signer/lib/index'\n\nexport const adaptEthersSigner = (signer: Signer): ReservoirWallet => {\n  return {\n    address: async () => {\n      return signer.getAddress()\n    },\n    handleSignMessageStep: async (stepItem) => {\n      const client = getClient()\n      const signData = stepItem.data?.sign\n      let signature: string | undefined\n      if (signData) {\n        // Request user signature\n        if (signData.signatureKind === 'eip191') {\n          client.log(['Execute Steps: Signing with eip191'], LogLevel.Verbose)\n          if (signData.message.match(/0x[0-9a-fA-F]{64}/)) {\n            // If the message represents a hash, we need to convert it to raw bytes first\n            signature = await signer.signMessage(arrayify(signData.message))\n          } else {\n            signature = await signer.signMessage(signData.message)\n          }\n        } else if (signData.signatureKind === 'eip712') {\n          client.log(['Execute Steps: Signing with eip712'], LogLevel.Verbose)\n          signature = await (\n            signer as unknown as TypedDataSigner\n          )._signTypedData(signData.domain, signData.types, signData.value)\n        }\n      }\n      return signature\n    },\n    handleSendTransactionStep: async (chainId, stepItem) => {\n      const { gas, ...stepData } = stepItem.data\n      const transaction = await signer.sendTransaction({\n        ...stepData,\n        ...(gas && {\n          gasLimit: gas,\n        }),\n      })\n      return transaction.hash as `0x${string}`\n    },\n  }\n}\n"],"names":[],"version":3,"file":"index.module.js.map"}